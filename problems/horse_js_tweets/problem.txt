このエクササイズでは、@horse_js の 2,000 以上のツイートを格納した
LevelDB ストアが与えられます。あなたの仕事は、データセットに対して
特定の日付につぶやかれたツイートを問い合わせることです。

それぞれのエントリーは一つのツイートです。キーはそのツイートが送られ
た正確な時刻で、標準の ISO 日付フォーマットです。（すなわち `Date`
オブジェクトの `toISOString()` メソッドによって生成されるフォーマット）。
エントリーの値は単にツイートの内容を表す String です。

単一の関数を export する{bold}モジュール{/bold}（プログラムではなく）
を書いてください。その関数が取る 3 つの引数は: 既存の LevelUP データ
ベースのインスタンス、YYYY-MM-DD 形式の日付文字列、そしてコールバック
関数です。

コールバックに返される最初の引数は、エラーが発生した場合はそのエラー、
なければ null であるべきです。

エラーがなかった場合、第二引数は{bold}各要素がツイートの String テキスト
な配列であるべきです。{/bold}

その配列は、あなたの関数の第二引数として与えられる{bold}一つの日{/bold}
の整列されたツイートを格納しているべきです。他の日のツイートを返しては
いけません。

問い合わせが正確な範囲に対するものであることを確認するため、あなたの
解答は公式の解答に対してチェックされます。出力は「ストリームされた
エントリー」の数を含みます。

---------------------------------------------------------------------
ヒント:

ISO 日付フォーマットは常に辞書学的にソートされます。つまり、特別なこと
をしなくてもデータストア中のツイートは日付/時間の順で出てきます。

このエクササイズでは例の `createReadStream()` メソッドを使う必要がある
でしょうが、さらにエントリーの範囲を必要なデータだけに制限する必要がある
でしょう。つまり、「範囲問い合わせ」を実行しなければなりません。

デフォルトでは範囲はストア全体ですが、start と/または end キーで狭める
ことができます。このエクササイズでは特定の日付から開始して、ストアの
最後まで続くようにすると良いでしょう。

範囲問い合わせの力の一部は、start と end のキーが存在する必要がないと
いう事実から来ています。start キーが存在しなければ、データはソート順で
次に来るキーのエントリーから始まります。end キーがなければ、問い合わせ
はソート順で end キーの前に来るキーのエントリーで終わります。

範囲を指定するには、範囲のキーを定義する 'start' と/または 'end' プロパティ
のあるオプションオブジェクトを `createReadStream()` に渡す必要があります:

  db.createReadStream({ start: 'bar', end: 'foo' })...

範囲キーは存在する必要がないので、あなたが探しているキーのプレフィックス
を渡すだけで良いことに留意してください。例えば '2010' は '2010' で始まる
最初のキーまでジャンプし、結局は '2010-09-04T03:51:30.929Z' にマッチする
かもしれません。

範囲の 'end' キーは包括的なので、必要なファイルだけにマッチする疑似キー
を作る必要があるでしょう。もし 'start' に '2010' と 'end' に '2011' を
使った場合、'2010' と '2011' で始まる全てのエントリーを取得することに
なります。LevelUP でこれを行う慣用的な方法（しかし唯一の方法ではない）
は、キーの最後に最後の ASCII 文字である '\xff' を加えることです。そう
すると 'start' に '2010' と 'end' に '2010\xff' は、'2010' で始まる
キーだけにマッチするでしょう。
